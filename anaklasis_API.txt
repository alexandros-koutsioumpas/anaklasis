anaklasis.fit(project, in_file, units, fit_mode,fit_weight, method, resolution, patches, system, model_param, multi_param, model_constraints, background, scale, experror, plot, fast)
	

	This function performs fits of x-ray and neutron reflection data

	:param project: string containing the name of the project. All output files
	 are saved in a directory with the same name. If project name is 'none'
	 no output files are written on disk. 

	:param in_file: list of M string elements. 

	 Syntax:

	 in_file = ['file1','file2',...,'fileM']

	 Each element is the path to an ASCII file containing reflectivity data. 
	 The file structure should be in column format ( Q, Reflectivity, error in 
	 reflectivity (dR), error in Q (dQ)). If a third column (dR) is not present
	 in the data, set experror=False (see below). If a 4th column (dQ) is 
	 present you may take pointwise resolution into account by setting resolution
	 equal to -1 (see below). Additional columns will be ignored. 
	 Lines beginning with '#' can be present and are considered as comments. 
	 Reflectivity should be footprint corrected.

	:param units: list of M string elements that can be either 'A' inverse
	 Angstrom or 'nm' inverse nanometers, describing the units of momentum
	 transfer (Q) in each of the corresponding input files.  

	 Syntax:

	 units = ['units1','units2',...,'unitsM']

	:fit_mode: integer that can take values 0 (linear figure of merit) or 
	 1 (log10 figure of merit)

	:method: string that can be either 'simple', either 'mcmc' or 'bootstrap'
	With 'simple' method, parameter uncertainty calculation is performed by
	calculation of the Hessian Matrix. With 'mcmc' method a Markov Chain Monte
	Carlo run is performed and together with parameter uncertainty estimation
	a corner plot with parameter correlations is exported. With 'bootstrap' 
	also parameter correlation is exported however note that this methods is
	far more computationally intensive than 'mcmc'.

	:resolution: list of M float elements. Each element is the dQ/Q resolution of
	the corresponding input data in param in_file

	Syntax:

		resolution = [res1, res2, ... , resM]

	 for example res1 describes the resolution of the data present in 'file1'.

	Note that if a 4th dQ column is present in the in_file, you may set res = -1
	so that pointwise dQ/Q resolution is taken into account.

	:patches: list of surface coverage of each defined model. In case of a single
	 defined model (most usual case) the definition has the following syntax

	Syntax:
		patches = [1.0]

	in case of K defined models

	Syntax:
	 	patches = [coverage_1, coverage_2 ... coverage_K]

	where the sum of all coverages should add up to 1.

	:system: List of lists containing defined models.
	 Each model is represented as a list of N+1 lists(lines) that contain 6 elements.


	Syntax:
		system = [[
			[  Re_sld0, Im_sld0, d0, sigma0, solv0, 'layer0'],
			[  Re_sld1, Im_sld1, d1, sigma1, solv1, 'layer1'],
			[  Re_sld2, Im_sld2, d2, sigma2, solv2, 'layer2'],
			.
			.
			.
			[  Re_sldN, Im_sldN, dN, sigmaN, solvN, 'layerN'],
			]]

	 If more than one models needs to be defined, more lists can be appended as:

	 	system.append([
			[  Re_sld0, Im_sld0, d0, sigma0, solv0, 'layer0'],
			[  Re_sld1, Im_sld1, d1, sigma1, solv1, 'layer1'],
			[  Re_sld2, Im_sld2, d2, sigma2, solv2, 'layer2'],
			.
			.
			.
			[  Re_sldN, Im_sldN, dN, sigmaN, solvN, 'layerN'],
	 		])

	 Each line (6 element list) represents a layer, from layer 0 (semi-infinite
	 fronting) to layer N (semi-infinite backing). The elements of the list 
	 correspond to Real sld (in 10^-6 A^-2) , Imaginary sld in 10^-6 A^-2,
	 thickness (in Angstrom), roughness (in Angstrom), solvent volumer fraction
	 (0 to 1) and layer description (string) respectively. All elements (except
	 description) can be numerical values or SymPy expressions (string) involving
	 global and multi parameters. Additionally in the SymPy expressions the 
	 integer (n) can be used, that represents the number of the layer from 0 
	 to N, and/or the summation integers ii,jj,kk, and/or the variables x,y,z
	 than may be used in SymPy integrals or derivatives.


	 When solv0 = 0 and solvN = 1 (fronting and backing solvent volume fraction)
	 then the solvent volume fraction parameter assumes that the backing layer
	 represents a semi-infinite liquid medium and that the liquid may
	 penetrate layers 1 to N-1 (usual in measurements at the solid/liquid or
	 air/liquid interface). 

	 When solv0 = 1 and solvN = 0 (fronting and backing solvent volume fraction)
	 then the solvent volume fraction parameter assumes that the fronting layer
	 represents a semi-infinite liquid medium and that the liquid may
	 penetrate layers 1 to N-1 (usual in measurements at the solid/liquid or
	 air/liquid interface). 

	 When solv0 = 0 and solvN = 0 (fronting and backing solvent volume fraction)
	 all solv values should be set zero. Any non zero value is ignored. 

	 Note that sigma_i represents the roughness between layer_i and layer_(i+1) 

	:model_param: Global parameter list of X 5-element lists.

	Syntax:
		param = [
			['p0', p0_A, p0_B, 'p0_description','p0_type'],
			['p1', p1_A, p1_B, 'p1_description','p1_type'],
			.
			.
			.
			['pX', pX_A, pX_B, 'pX_name''pX_type'],
			]

	 Up to X=20 global parameters can be defined. The names should be strings of
	 the form 'p0','p1' ... 'p19' respectively. The two last elements of each 
	 global parameter are strings defining the description and type of the 
	 parameter. The type can be either 'uniform' or 'normal'. In case of uniform
	 type, The two values p_A/P_B represent the min/max bound of a 
	 uniform distribution. In case of normal type the values p_A/p_B represent
	 the mean value and standard deviation (sd) of a normal distribution.
	 If min is equal to max value or standard deviation is zero, then the global 
	 parameter is considered as fixed, otherwise is left free to vary within the 
	 min/max bounds or within mean - 3*sd/mean + 3*sd respectively.

	:multi_param: Multi parameter list of Y 2+2*M-element lists, where M is the
	 number of input curves.

	Syntax:
		param = [
			['m0', m0_A1, m0_B1, ..., m0_AM, m0_BM, 'm0_description','m0_type'],
			['m1', m1_A1, m1_B1, ..., m1_AM, m1_BM, 'm1_description','m1_type'],
			.
			.
			.
			['mY', mY_A1, mY_B1, ..., mY_AM, mY_BM, 'mY_description','mY_type'],
			]


	 Up to Y=20 multi parameters can be defined. The names should be strings of
	 the form 'm0','m1' ... 'm19' respectively. The two last elements of each 
	 multi parameter are strings defining the description and type of the 
	 parameter. The type can be either 'uniform' or 'normal'. In case of uniform
	 type, the two values m_A/m_B represent the min/max bounds of a 
	 uniform distribution. In case of normal type the values m_A/m_B represent
	 the mean value and standard deviation (sd) of a normal distribution.
	 If min is equal to max value or standard deviation is zero, then the multi 
	 parameter is considered as fixed, otherwise is left free to vary within the 
	 min/max bounds or within mean - 3*sd/mean + 3*sd respectively.

	 The difference with global parameters is than the m_A/M_B value of a multi
	 parameter is different for each input curve, thus M (m_A/M_B) value pairs
	 need to be defined, where M is the number of input curves.

	:model_constraints: list of strings containing inequality expressions.

	Syntax:

		model_constraints = [
			'expression1',
			'expression2'.
			.
			.
			.
			'expressionZ',]

	 Any sympy valid expression (string) can be used involving defined global and 
	 multi parameters. An example expression is the following '2*p1/p0>1'.

	:background: list of M lists that contain two numbers and type (normal or uniform)
	 For uniform type these two numbers represent the lower and upper bound of the 
	 instrumental background of the  corresponding data. If the upper and lower value
	 is the same, the parameter is considered fixed durind the fit, otherwise it is 
	 considered as a free to vary within the min/max bounds. In case were the
	 type is normal these two numbers represent the mean and standard deviation of the 
	 instrumental background of the  corresponding data. If the standard deviation is
	 zero, the parameter is considered fixed durind the fit, otherwise it is 
	 considered as a free to vary within mean-3*sd/mean+3*sd.

	Syntax: 

		background = [
			[bkg_A1,bkg_B1,'type'],
			[bkg_A2,bkg_B2,'type'],
			.
			.
			.
			.
			[bkg_AM,bkg_BM],'type'],
			]	

	 for example [bkg_min1,bkg_max1] describe the lower and upper bound of the
	 background of the data present in 'file1'.

	 Note: Theoretical reflectivity is calculated as

	 	R = scale * R(Q) + background

	:scale: list of M lists that contain two numbers and type (normal or uniform)
	 For uniform type these two numbers represent the lower and upper bound of the 
	 scale of the corresponding data. If the upper and lower value is the same, 
	 the parameter is considered fixed durind the fit, otherwise it is 
	 considered as a free to vary within the min/max bounds. In case were the
	 type is normal these two numbers represent the mean and standard deviation of the 
	 scale of the  corresponding data. If the standard deviation is
	 zero, the parameter is considered fixed durind the fit, otherwise it is 
	 considered as a free to vary within mean-3*sd/mean+3*sd.

	Syntax: 

		scale = [
			[scale_A1,scale_B1,'type'],
			[scale_A2,scale_B2,'type'],
			.
			.
			.
			.
			[scale_AM,scale_BM,'type'],]

	 for example [scale_min1,scale_max1] describe the lower and upper bound of
	 the scale of the data present in 'file1'.

	 Note: Theoretical reflectivity is calculated as

	 	R = scale * R(Q) + background

	:param experror: Boolean. Set as True, if all input files contain a third 
	column with Reflectivity uncertainty. Set as False, if at least one of the
	input files contains no Reflectivity uncertainty. Also, if all data contain
	a third column but for some reason Reflectivity uncertainty is considered
	as non-reliable, you may set the parameter to False thus ignoring errors.

	:param plot: Boolean. If True, an interactive plot is displayed at the end
	of the calculations.

	:param fast: Boolean. If True, a small differential evolution population size
	is used. If False a large differential evolution population size is used.

	:return: a tuple containing 8 lists: 

	return[0][i][j][Q,R,RxQ^4] <- reflectivity list
	return[1][i][j][z,sld,sd sld*] <- sld list
	return[2][i][j][z,solv, sd solv*] <- solvent volume fraction list
	return[3][k][mean, sd*] <- global_parameter fit list
	return[4][l][i][mean, sd*] <- multi_parameter fit list
	return[5][i][mean, sd*] <- background fit list
	return[6][i][mean, sd*] <- scale fit list
	return[7][i][value] <- chi squared list 

	* if available 

	where i the curve number starting from 0
	      j the model number starting from 0
	      k the global_parameter number starting from 0
	      l the multi_parameter number starting from 0

	 In case of error a string that describes the error that occurred, is returned.

	 Output files are written in the created directory 'project' and include
	 a log file, reflectivity curves in R vs Q and R vs Q^4, solvent volume 
	 fraction and scattering length density profiles. Also corresponding PDF
	 figures are saved together with the ASCII data files.

-------------------------------------------------------------------------------------------


anaklasis.calculate(project,resolution, patches, system, system_param, background, scale, qmax, plot)

	This function performs x-ray and neutron reflectivity curve calculations 

	:param project: string containing the name of the project. All output files
	 are saved in a directory with the same name. If project name is 'none'
	 no output files re written on disk. 

	:resolution: list of single float. The element is the dQ/Q resolution

	Syntax:

		resolution = [res1]

	:patches: list of surface coverage of each defined model. In case of a single
	 defined model (most usual case) the definition has the following syntax

	Syntax:
		patches = [1.0]

	in case of K defined models

	Syntax:
	 	patches = [coverage_1, coverage_2 ... coverage_K]

	where the sum of all coverages should add up to 1.

	:system: List of lists containing defined models.
	 Each model is represented as a list of N+1 lists(lines) that contain 6 elements.

	Syntax:
		system = [[
			[  Re_sld0, Im_sld0, d0, sigma0, solv0, 'layer0'],
			[  Re_sld1, Im_sld1, d1, sigma1, solv1, 'layer1'],
			[  Re_sld2, Im_sld2, d2, sigma2, solv2, 'layer2'],
			.
			.
			.
			[  Re_sldN, Im_sldN, dN, sigmaN, solvN, 'layerN'],
			]]

	 If more than one models needs to be defined, more lists can be appended as:

	 	system.append([
			[  Re_sld0, Im_sld0, d0, sigma0, solv0, 'layer0'],
			[  Re_sld1, Im_sld1, d1, sigma1, solv1, 'layer1'],
			[  Re_sld2, Im_sld2, d2, sigma2, solv2, 'layer2'],
			.
			.
			.
			[  Re_sldN, Im_sldN, dN, sigmaN, solvN, 'layerN'],
	 		])

	 Each line (6 element list) represents a layer, from layer 0 (semi-infinite
	 fronting) to layer N (semi-infinite backing). The elements of the list 
	 correspond to Real sld (in 10^-6 A^-2) , Imaginary sld in 10^-6 A^-2,
	 thickness (in Angstrom), roughness (in Angstrom), solvent volumer fraction
	 (0 to 1) and layer description (string) respectively. All elements (except
	 description) can be numerical values or sympy expressions (string) involving
	 global and multi parameters. Additionally in the sympy expressions the 
	 integer (n) can be used, that represents the number of the layer from 0 
	 to N, and/or the summation integers ii,jj,kk, and/or the variables x,y,z
	 than may be used in SymPy integrals or derivatives.


	 When solv0 = 0 and solvN = 1 (fronting and backing solvent volume fraction)
	 then the solvent volume fraction parameter assumes that the backing layer
	 represents a semi-infinite liquid medium and that the liquid may
	 penetrate layers 1 to N-1 (usual in measurements at the solid/liquid or
	 air/liquid interface). 

	 When solv0 = 1 and solvN = 0 (fronting and backing solvent volume fraction)
	 then the solvent volume fraction parameter assumes that the fronting layer
	 represents a semi-infinite liquid medium and that the liquid may
	 penetrate layers 1 to N-1 (usual in measurements at the solid/liquid or
	 air/liquid interface). 

	 When solv0 = 0 and solvN = 0 (fronting and backing solvent volume fraction)
	 all solv values should be set zero. Any non zero value is ignored. 

	 Note that sigma_i represents the roughness between layer_i and layer_(i+1) 

	:system_param: Global parameter list of X 3-element lists.

	Syntax:
		system_param = [
			['p0', p0_value, 'p0_description'],
			['p1', p1_value, 'p1_description'],
			.
			.
			.
			['pX', pX_valuex, 'pX_name'],
			]

	 Up to X=20 global parameters can be defined. The name should be strings of
	 the form 'p0','p1' ... 'p19' respectively. The last element of each global
	 parameter is also a string (description). The middle elements are floats
	 corresponding to the value of the parameter.

	:background: list with single numerical element that corresponds to the 
	background.

	Syntax: 

		background = [bkg_value]	

	 Note: Theoretical reflectivity is calculated as

	 	R = scale * R(Q) + background

	:scale: list with single numerical element that corresponds to the 
	scaling of the reflectivity curve.

	Syntax: 

		scale = [scale_value]

	 Note: Theoretical reflectivity is calculated as

	 	R = scale * R(Q) + background

	:param plot: Boolean. If True, an interactive plot is displayed at the end
	of the calculations. 

	:qmax: list with single numerical element that corresponds to the max
	Q in inverse Angstrom.

	Syntax:

		qmax = [Qmax_value]

	:return: a tuple containing 3 lists: 

	return[0][i][Q,R,RxQ^4] <- reflectivity list
	return[1][i][z,sld] <- sld list
	return[2][i][z,solv] <- solvent volume fraction list

	where i is the model number starting from 0

	 In case of error a string that describes the error that occurred, is returned.

	 Output files are written in the created directory 'project' and include
	 a log file, reflectivity curves in R vs Q and R vs Q^4, solvent volume 
	 fraction and scattering length density profiles. Also corresponding PDF
	 figures are saved together with the ASCII data files.

-------------------------------------------------------------------------------------------

anaklasis.compare(project, in_file, units, resolution, patches, system, system_param, background, scale, qmax,  experror, plot)

	This function performs comparison of x-ray and neutron reflection data
	with theoretical reflectivity from a defined model.

	:param project: string containing the name of the project. All output files
	 are saved in a directory with the same name. If project name is 'none'
	 no output files re written on disk. 

	:param in_file: list of single string element. 

	 Syntax:

	 in_file = ['file']

	 which is the path to an ASCII file containing the reflectvity data. 
	 The file structure should be in column format ( Q, Reflectivity, error in 
	 reflectivity (dR), error in Q (dQ)). If a third column (dR) is not present
	 in the data, set experror=False (see below). If a 4th column (dQ) is 
	 present you may take pointwise resolution into account by setting resolution
	 equal to -1 (see below). Additional columns will be ignored. 
	 Lines beginning with '#' can be present and are considered as comments. 
	 Reflectivity should be footprint corrected.

	:param units: list of a single string elementthat can be either 'A' inverse
	 Angstrom or 'nm' inverse nanometers, describing the units of momentum
	 transfer (Q) in the input file.  

	 Syntax:

	 units = ['units1']

	:resolution: list of single float element corresponding to the dQ/Q resolution 
	of the corresponding input data

	Syntax:

		resolution = [res_value]

	Note that if a 4th dQ column is present in the in_file, you may set res_value
	 = -1, so that pointwise dQ/Q resolution is taken into account.

	:patches: list of surface coverage of each defined model. In case of a single
	 defined model (most usual case) the definition has the following syntax

	Syntax:
		patches = [1.0]

	in case of K defined models

	Syntax:
	 	patches = [coverage_1, coverage_2 ... coverage_K]

	where the sum of all coverages should add up to 1.

	:system: List of lists containing defined models.
	 Each model is represented as a list of N+1 lists that contain 6 elements.


	Syntax:
		system = [[
			[  Re_sld0, Im_sld0, d0, sigma0, solv0, 'layer0'],
			[  Re_sld1, Im_sld1, d1, sigma1, solv1, 'layer1'],
			[  Re_sld2, Im_sld2, d2, sigma2, solv2, 'layer2'],
			.
			.
			.
			[  Re_sldN, Im_sldN, dN, sigmaN, solvN, 'layerN'],
			]]

	 If more than one models needs to be defined, more lists can be appended as:

	 	system.append([
			[  Re_sld0, Im_sld0, d0, sigma0, solv0, 'layer0'],
			[  Re_sld1, Im_sld1, d1, sigma1, solv1, 'layer1'],
			[  Re_sld2, Im_sld2, d2, sigma2, solv2, 'layer2'],
			.
			.
			.
			[  Re_sldN, Im_sldN, dN, sigmaN, solvN, 'layerN'],
	 		])

	 Each line (6 element list) represents a layer, from layer 0 (semi-infinite
	 fronting) to layer N (semi-infinite backing). The elements of the list 
	 correspond to Real sld (in 10^-6 A^-2) , Imaginary sld in 10^-6 A^-2,
	 thickness (in Angstrom), roughness (in Angstrom), solvent volumer fraction
	 (0 to 1) and layer description (string) respectivery. All elements (except
	 description) can be numerical values or sympy expressions (string) involving
	 global and multi parameters. Additionally in the sympy expressions the 
	 integer (n) can be used, that represents the number of the layer from 0 
	 to N, and/or the summation integers ii,jj,kk, and/or the variables x,y,z
	 than may be used in SymPy integrals or derivatives.


	 When solv0 = 0 and solvN = 1 (fronting and backing solvent volume fraction)
	 then the solvent volume fraction parameter assumes that the backing layer
	 represents a semi-infinite liquid medium and that the liquid may
	 penetrate layers 1 to N-1 (usual in measurements at the solid/liquid or
	 air/liquid interface). 

	 When solv0 = 1 and solvN = 0 (fronting and backing solvent volume fraction)
	 then the solvent volume fraction parameter assumes that the fronting layer
	 represents a semi-infinite liquid medium and that the liquid may
	 penetrate layers 1 to N-1 (usual in measurements at the solid/liquid or
	 air/liquid interface). 

	 When solv0 = 0 and solvN = 0 (fronting and backing solvent volume fraction)
	 all solv values should be set zero. Any non zero value is ignored. 

	 Note that sigma_i represents the roughness between layer_i and layer_(i+1) 

	:system_param: Global parameter list of X 3-element lists.

	Syntax:
		system_param = [
			['p0', p0_value, 'p0_description'],
			['p1', p1_value, 'p1_description'],
			.
			.
			.
			['pX', pX_valuex, 'pX_name'],
			]

	 Up to X=20 global parameters can be defined. The name should be strings of
	 the form 'p0','p1' ... 'p19' respectively. The last element of each global
	 parameter is also a string (description). The middle elements are floats
	 corresponding to the value of the parameter.

	:background: list with single numerical element that corresponds to the 
	background.

	Syntax: 

		background = [bkg_value]	

	 Note: Theoretical reflectivity is calculated as

	 	R = scale * R(Q) + background

	:scale: list with single numerical element that corresponds to the 
	scaling of the reflectivity curve.

	Syntax: 

		scale = [scale_value]

	 Note: Theoretical reflectivity is calculated as

	 	R = scale * R(Q) + background

	:param plot: Boolean. If True, an interactive plot is displayed at the end
	of the calculations.

	:return: a tuple containing 4 lists: 

	return[0][i][Q,R,RxQ^4] <- reflectivity list
	return[1][i][z,sld] <- sld list
	return[2][i][z,solv] <- solvent volume fraction list
	return[3][value] <- chi squared list 

	where i the model number starting from 0

	In case of error a string that describes the error that occurred, is returned.

	:param experror: Boolean. Set as True, if all input files contain a third 
	column with Reflectivity uncertainty. Set as False, if at least one of the
	input files contains no Reflectivity uncertainty. Also, if all data contain
	a third column but for some reason Reflectivity uncertainty is considered
	as non-reliable, you may set the parameter to False thus ignoring errors.

	:param plot: Boolean. If True, an interactive plot is displayed at the end
	of the calculations.

	:param fast: Boolean. If True, a small differential evolution population size
	is used. If False a large differential evolution population size is used.

	:return: Reflectivity list, Profile List, Solvent volume fraction list and
	chi squared list. Reflectivity list contains (Q,R,RQ^4) data. Profile and
	Solvent list have dimensions model X 2 (z, Profile).
	In case of error a string that describes the error that occured. is returned. 

	 Output files are written in the created directory 'project' and include
	 a log file, reflectivity curves in R vs Q and R vs Q^4, solvent volume 
	 fraction and scattering length density profiles. Also corresponding PDF
	 figures are saved together with the ASCII data files.